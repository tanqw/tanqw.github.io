<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx+KeepAlived实现服务高可用</title>
      <link href="/posts/20ce.html"/>
      <url>/posts/20ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-keepAlived实现服务高可用"><a href="#Nginx-keepAlived实现服务高可用" class="headerlink" title="Nginx + keepAlived实现服务高可用"></a>Nginx + keepAlived实现服务高可用</h1><h2 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h2><p>​        <em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为<a href="https://baike.baidu.com/item/%E4%BF%84%E7%BD%97%E6%96%AF/125568">俄罗斯</a>访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>​        其将<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3814213">源代码</a>以类<a href="https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E8%AF%81/10642412">BSD许可证</a>的形式发布，因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而<a href="https://baike.baidu.com/item/%E9%97%BB%E5%90%8D/2303308">闻名</a>。2011年6月1日，nginx 1.0.4发布。</p><p>​        Nginx是一款<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835">轻量级</a>的<a href="https://baike.baidu.com/item/Web/150564">Web</a> 服务器/<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>服务器及<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106">电子邮件</a>（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806">并发</a>能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、<a href="https://baike.baidu.com/item/%E4%BA%AC%E4%B8%9C/210931">京东</a>、<a href="https://baike.baidu.com/item/%E6%96%B0%E6%B5%AA/125692">新浪</a>、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%98%93/185754">网易</a>、<a href="https://baike.baidu.com/item/%E8%85%BE%E8%AE%AF/112204">腾讯</a>、<a href="https://baike.baidu.com/item/%E6%B7%98%E5%AE%9D/145661">淘宝</a>等。<a href="https://baike.baidu.com/item/nginx/3817705?fr=aladdin">描述来源百度百科</a></p><h2 id="什么是高可用？"><a href="#什么是高可用？" class="headerlink" title="什么是高可用？"></a>什么是高可用？</h2><p>​        “高可用性”HA（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。如果一个系统能够一直提供服务，那么这个可用性则是百分之百，但是天有不测风云。所以我们只能尽可能的去减少服务的故障。</p><h2 id="什么是KeepAlived？"><a href="#什么是KeepAlived？" class="headerlink" title="什么是KeepAlived？"></a>什么是KeepAlived？</h2><h3 id="KeepAlived简介"><a href="#KeepAlived简介" class="headerlink" title="KeepAlived简介"></a>KeepAlived简介</h3><p>​        KeepAlived是Linux下一个轻量级别的高可用解决方案。高可用(High Avalilability,HA)，其实两种不同的含义：广义来讲，是指整个系统的高可用行，狭义的来讲就是之主机的冗余和接管，它与HeartBeat RoseHA 实现相同类似的功能，都可以实现服务或者网络的高可用，但是又有差别，HeartBeat是一个专业的、功能完善的高可用软件，它提供了HA 软件所需的基本功能，比如：心跳检测、资源接管，检测集群中的服务，在集群节点转移共享IP地址的所有者等等。HeartBeat功能强大，但是部署和使用相对比较麻烦，与HeartBeat相比，KeepAlived主要是通过虚拟路由冗余来实现高可用功能，虽然它没有HeartBeat功能强大，但是KeepAlived部署和使用非常的简单，所有配置只需要一个配置文件即可以完成。</p><h3 id="VRRP协议与工作原理"><a href="#VRRP协议与工作原理" class="headerlink" title="VRRP协议与工作原理"></a>VRRP协议与工作原理</h3><p>​        在现实的网络环境中。主机之间的通信都是通过配置静态路由或者(默认网关)来完成的，而主机之间的路由器一旦发生故障，通信就会失效，因此这种通信模式当中，路由器就成了一个单点瓶颈，为了解决这个问题，就引入了VRRP协议。</p><p>​        熟悉网络的学员对VRRP协议应该不陌生，它是一种主备模式的协议，通过VRRP可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信，这其中涉及到两个概念：物理路由器和虚拟路由器。</p><p>​        VRRP可以将两台或者多台物理路由器设备虚拟成一个虚拟路由，这个虚拟路由器通过虚拟IP（一个或者多个)对外提供服务，而在虚拟路由器内部十多个物理路由器协同工作，同一时间只有一台物理路由器对外提供服务，这台物理路由设备被成为：主路由器（Master角色)，一般情况下Master是由选举算法产生，它拥有对外服务的虚拟IP，提供各种网络功能，如：ARP请求，ICMP 数据转发等，而且其它的物理路由器不拥有对外的虚拟IP，也不提供对外网络功能，仅仅接收MASTER的VRRP状态通告信息，这些路由器被统称为“BACKUP的角色”，当主路由器失败时，处于BACKUP角色的备份路由器将重新进行选举，产生一个新的主路由器进入MASTER角色，继续提供对外服务，整个切换对用户来说是完全透明的。<br>​        每个虚拟路由器都有一个唯一的标识号，称为VRID，一个VRID与一组IP地址构成一个虚拟路由器，在VRRP协议中，所有的报文都是通过IP多播方式发送的，而在一个虚拟路由器中，只有处于Master角色的路由器会一直发送VRRP数据包，处于BACKUP角色的路由器只会接受Master角色发送过来的报文信息，用来监控Master运行状态，一一般不会发生BACKUP抢占的情况，除非它的优先级更高，而当MASTER不可用时，BACKUP也就无法收到Master发过来的信息，于是就认定Master出现故障，接着多台BAKCUP就会进行选举，优先级最高的BACKUP将称为新的MASTER，这种选举角色切换非常之快，因而保证了服务的持续可用性。</p><h3 id="什么是KeepAlived"><a href="#什么是KeepAlived" class="headerlink" title="什么是KeepAlived"></a>什么是KeepAlived</h3><p>​        KeepAlived起初是为LVS设计的，专门用来监控集群系统中各个服务节点的状态，它根据TCP/IP参考模型的第三、第四层、第五层交换机制检测每个服务节点的状态，如果某个服务器节点出现异常，或者工作出现故障，KeepAlived将检测到，并将出现的故障的服务器节点从集群系统中剔除，这些工作全部是自动完成的，不需要人工干涉，需要人工完成的只是修复出现故障的服务节点。后来KeepAlived又加入了VRRP的功能，VRRP（Vritrual Router Redundancy Protocol,虚拟路由冗余协议)出现的目的是解决静态路由出现的单点故障问题，通过VRRP可以实现网络不间断稳定运行，因此KeepAlived一方面具有服务器状态检测和故障隔离功能，另外一方面也有HA cluster功能，下面介绍一下VRRP协议实现的过程。</p><h3 id="KeepAlived的工作原理"><a href="#KeepAlived的工作原理" class="headerlink" title="KeepAlived的工作原理"></a>KeepAlived的工作原理</h3><p>​        上面我们介绍了KeepAlived通过VRRP实现高可用性的工作原理，而KeepAlived作为一个高性能集群软件，它还能实现对集群中服务器运行状态的监控以及故障隔离，下面我们介绍一下KeepAlived对服务器运行状态和故障隔离的工作原理。</p><p>​        KeepAlived工作在TCP/IP 参考模型的 三层、四层、五层，也就是分别为：网络层，</p><p>传输层和应用层，根据TCP、IP参数模型隔层所能实现的功能，KeepAlived运行机制如下：</p><p>​        <strong>在网络层：我们知道运行这4个重要的协议，互联网络IP协议，互联网络可控制报文协议ICMP、地址转换协议ARP、反向地址转换协议RARP，在网络层KeepAlived在网络层采用最常见的工作方式是通过ICMP协议向服务器集群中的每一个节点发送一个ICMP数据包(有点类似与Ping的功能)，如果某个节点没有返回响应数据包，那么认为该节点发生了故障，KeepAlived将报告这个节点失效，并从服务器集群中剔除故障节点。</strong></p><p>​        <strong>在传输层：提供了两个主要的协议：传输控制协议TCP和用户数据协议UDP，传输控制协议TCP可以提供可靠的数据输出服务、IP地址和端口，代表TCP的一个连接端，要获得TCP服务，需要在发送机的一个端口和接收机的一个端口上建立连接，而KeepAlived在传输层里利用了TCP协议的端口连接和扫描技术来判断集群节点的端口是否正常，比如对于常见的WEB服务器80端口。或者SSH服务22端口，KeepAlived一旦在传输层探测到这些端口号没有数据响应和数据返回，就认为这些端口发生异常，然后强制将这些端口所对应的节点从服务器集群中剔除掉。</strong></p><p>​        <strong>在应用层：可以运行FTP，TELNET，SMTP，DNS等各种不同类型的高层协议，KeepAlived的运行方式也更加全面化和复杂化，用户可以通过自定义KeepAlived工作方式，例如：可以通过编写程序或者脚本来运行KeepAlived，而KeepAlived将根据用户的设定参数检测各种程序或者服务是否允许正常，如果KeepAlived的检测结果和用户设定的不一致时，KeepAlived将把对应的服务器从服务器集群中剔除</strong></p><p><a href="https://www.cnblogs.com/losbyday/p/5841830.html">KeepAlived介绍来源</a></p><h2 id="常见的互联网结构"><a href="#常见的互联网结构" class="headerlink" title="常见的互联网结构"></a>常见的互联网结构</h2><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/%E5%85%B8%E5%9E%8B%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%93%E6%9E%84.png" alt="典型互联网结构"></p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/%E5%85%B8%E5%9E%8B%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%93%E6%9E%84.png" alt="典型多模块互联网结构"></p><p>​        上图代理服务器的Nginx可以和代理Web-Service的不为同一台。</p><p>​        从上图可以看出在生产环境上很多时候是以<code>Nginx</code>做反向代理对外提供服务，但是<code>Nginx</code>难免会遇见故障，如果<code>Nginx</code>服务器宕机那么所有对外提供的接口都将导致无法访问。系统还有很多地方都能实现高可用，我今天分享的是实现服务的Nginx服务的高可用。</p><p>​        所以我们实现【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p><h2 id="故障说明"><a href="#故障说明" class="headerlink" title="故障说明"></a>故障说明</h2><p>​        例如上图的典型多模块互联网结构图，如果我们是前后端分离的项目，后台服务有多个模块，那么这时通常的做法是通过一个Nginx服务器反向代理这些模块分别部署的服务器，对外提供一个统一的URL地址供Web-Service端调用，Nginx根据Web-Service调用的请求URL，转发请求给对应的服务器上的服务。如果这些转发URL请求的Nginx服务器挂了，那么就无法再进行请求转发，Web-Service端也就会请求报错。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>两台虚拟机IP为：192.168.102.132/133地址以你的实际地址为准</p><p>更换yum源：</p><p>下载wget(下载新的CentOS-Base.repo 时用到也可以不下载；使用curl代替)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install wget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>备份源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载新的CentOS-Base.repo 到 /etc/yum.repos.d/ (CentOS7)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清除缓存</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum clean all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成缓存</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装JDK8"><a href="#安装JDK8" class="headerlink" title="安装JDK8"></a>安装JDK8</h3><p>去<a href="https://www.oracle.com/index.html">Oracle官网</a>下载JDK8（PS：注意选择Linux对应的版本下载）</p><p>创建目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/java/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后，使用xftp上传到虚拟机/usr/local/java/目录下，进入/usr/local/java/执行解压命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf jdk-8u301-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后/usr/local/java/目录下的文件</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924113356605.png" alt="image-20210924113356605"></p><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在末尾添加</p><pre class="line-numbers language-none"><code class="language-none">export JAVA_HOME=/usr/local/java/jdk1.8.0_301    #你对应的路径，如我上图解压完成的就是/usr/local/java/jdk1.8.0_301export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924113702447.png" alt="image-20210924113702447"></p><p>保存退出</p><p>使环境变量生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建软链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln -s /usr/local/java/jdk1.8.0_301/bin/java /usr/bin/java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现下图说明安装成功</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924113940922.png" alt="image-20210924113940922"></p><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p>在<a href="https://tomcat.apache.org/">Tomcat官网</a>下载Tomcat9安装包</p><p>创建目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/tomcat/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后，使用xftp上传到虚拟机/usr/local/tomcat/目录下，进入/usr/local/tomcat/执行解压命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf apache-tomcat-9.0.53.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后/usr/local/tomcat/目录下的文件</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924134351811.png" alt="image-20210924134351811"></p><p>进入tomcat的bin目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd apache-tomcat-9.0.53/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建setenv.sh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi setenv.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">CATALINA_HOME=/usr/local/tomcat/apache-tomcat-9.0.53   #你的Tomcat安装目录CATALINA_BASE=/usr/local/tomcat/apache-tomcat-9.0.53   #你的Tomcat安装目录JAVA_HOME/usr/local/java/jdk1.8.0_301                  #你的Java安装目录JRE_HOME=/usr/local/java/jdk1.8.0_301/jre/             #你的Java安装目录下的jre目录CATALINA_PID=/usr/local/tomcat/apache-tomcat-9.0.53/tomcat.pid    #你的Tomcat安装目录JAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>给setenv.sh权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x setenv.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换至/usr/lib/systemd/system</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/lib/systemd/system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建tomcat.service</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi tomcat.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">[Unit]Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/tomcat/apache-tomcat-9.0.53/tomcat.pid   #和前面配置的CATALINA_PID一致ExecStart=/usr/local/tomcat/apache-tomcat-9.0.53/bin/startup.sh #/usr/local/tomcat/apache-tomcat-9.0.53你的Tomcat安装目录ExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>配置开机启动 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动Tomcat</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止Tomcat</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启Tomcat</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在游览器输入你的IP地址:8080看到一只小喵咪表示Tomcat安装成功并成功启动；如果不能访问检查是不是没有开放端口，因为是虚拟机所以我直接关闭防火墙也就行了，<strong>如果是生产环境不建议关闭防火墙，应该是开放对应的端口，如果是云服务器，例如阿里云ECS服务器，在云服务器的安全组里面配置开放对应的端口就可以了</strong></p><p>查看防火墙状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --state<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止防火墙</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>禁止防火墙开机启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl disable firewalld.service <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CentOS7开放端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone=public --add-port=8080/tcp --permanent  # 开放8080端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CentOS7关闭端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone=public --remove-port=8080/tcp --permanent  #关闭82080端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启防火墙</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开放端口后再次访问，就可以看到小猫咪了如下图</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924140343019.png" alt="image-20210924140343019"></p><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>安装所需插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install gcc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y pcre pcre-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y zlib zlib-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y openssl openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些插件都是安装Nginx所必须的，具体每个插件的作用就不做详细说明，有兴趣的自己百度就可以了。</p><p>下载Nginx，在<a href="http://nginx.org/en/download.html">Nginx官网下载地址</a>下载你需要的版本就可以了，这里我下载的是最新的nginx-1.20.1最新的稳定版本</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924142013728.png" alt="image-20210924142013728"></p><p>创建目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/nginx/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后，使用xftp上传到虚拟机/usr/local/nginx/目录下，进入/usr/local/nginx/执行解压命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf  nginx-1.20.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后/usr/local/nginx/目录下的文件,，解压完成应该只有下图红框框出来的两个文件，其余的是在nginx安装完成后有的</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924142250384.png" alt="image-20210924142250384"></p><p>进入刚刚解压出来的nginx-1.20.1文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd nginx-1.20.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下三个命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure    #配置Nginx编译选项,默认即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make   #编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make install   #编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>三个命令执行完成后切换到/usr/local/nginx安装目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/nginx/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入conf配置目录，配置nginx.conf文件（后面做高可用时需修改，现在暂时不需要）</p><p>切换目录到/usr/local/nginx/sbin下面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看nginx服务是否启动成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps -ef | grep nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924143113017.png" alt="image-20210924143113017"></p><p>如上图所示表示启动成功，在游览器里面输入你的IP地址，应该能看到下面的这张图</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924143307085.png" alt="image-20210924143307085"></p><p>如果不行，参考上面Tomcat安装，开放端口80</p><p>配置nginx开机启动</p><p>进入/lib/systemd/system/目录，创建nginx.service文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /lib/systemd/system/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">[Unit]Description=nginx After=network.target    [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx reloadExecStop=/usr/local/nginx/sbin/nginx quitPrivateTmp=true    [Install] WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>执行systemctl enable nginx.service使nginx开机启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结束nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h3><p><code>yum</code>方式直接安装即可，该方式会自动安装依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install keepalived<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>yum</code>方式安装的会生产配置文件在<code>/etc/keepalived</code>下：</p><p>切换到/etc/keepalived目录编辑keepalived.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /etc/keepalived<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi keepalived.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑keepalived.conf为以下内容(<strong>PS：当前操作的虚拟机为主机，后面还有一台虚拟机作为备机，两个虚拟机环境一致，唯一配置不同的就是keepalived.conf文件主机的state为MASTER；备机的为BACKUP</strong>)</p><pre class="line-numbers language-none"><code class="language-none">#检测脚本vrrp_script chk_http_port {    script "/usr/local/src/check_nginx_pid.sh" #心跳执行的脚本，检测nginx是否启动    interval 2                          #（检测脚本执行的间隔，单位是秒）    weight 2                            #权重}#vrrp 实例定义部分vrrp_instance VI_1 {    state MASTER            # 指定keepalived的角色，MASTER为主，BACKUP为备    interface ens33         # 当前进行vrrp通讯的网络接口卡(当前centos的网卡) 用ifconfig查看你具体的网卡    virtual_router_id 66    # 虚拟路由编号，主从要一直    priority 100            # 优先级，数值越大，获取处理请求的优先级越高    advert_int 1            # 检查间隔，默认为1s(vrrp组播周期秒数)    #授权访问    authentication {        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信        auth_pass 1111    }    track_script {        chk_http_port            #（调用检测脚本）    }    virtual_ipaddress {        192.168.102.199            # 定义虚拟ip(VIP)，可多设，每行一个    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>virtual_ipaddress</code> 里面可以配置vip,在线上通过vip来访问服务。</p><p><code>interface</code>需要根据服务器网卡进行设置通常查看方式 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip addr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>authentication</code>配置授权访问后备机也需要相同配置</p><p>进入/usr/local/src目录创建心跳执行的脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/src/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim check_nginx_pid.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">#!/bin/bash#检测nginx是否启动了A=`ps -C nginx --no-header |wc -l`        if [ $A -eq 0 ];then    #如果nginx没有启动就启动nginx                              systemctl start nginx                #重启nginx      if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then    #nginx重启失败，则停掉keepalived服务，进行VIP转移              killall keepalived                          fifi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>脚本授权</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 775 check_nginx_pid.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此我们需要的环境已经搭建完成，现在我们编写一个简单的服务，然后发布来测试一下，我用的是IntelliJ IDEA创建的一个Spring Boot项目</p><h2 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="创建测试项目"></a>创建测试项目</h2><p>创建过程如下</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924145830502.png" alt="image-20210924145830502"></p><p>填写你的项目信息</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924145847814.png" alt="image-20210924145847814"></p><p>如下为我的配置信息，勾选packaging为War会自动帮我们配置打包移除内置Spring Boot内置的Tomcat</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924150033206.png" alt="image-20210924150033206"></p><p>勾选你需要的依赖，因为是测试项目不需要任何依赖，所以直接点击Finish，等待项目创建完成</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924145928902.png" alt="image-20210924145928902"></p><p>创建完成后我们在目录下建一个controller文件夹，在下面建一个TestHighAvailabilityController.java文件，结构如下图</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924150339524.png" alt="image-20210924150339524"></p><p>这里有点注意事项；我们新创建的项目的配置文件为application.properties文件，我们修改其为application.yml然后在里面写入</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 9000     #配置项目启动端口,默认为8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们在TestHighAvailabilityController.java写入一下代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.tan.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @description: 高可用测试接口 * @author: tan * @email: tan2511217211@163.com * @date: 2021/9/23 23:18 **/@RestController@RequestMapping("/api")public class TestHighAvailabilityController {    @GetMapping("/test")    public String test(){        return "Message from IP: 192.168.102.132/3";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我为了后面能直观的看到高可用实现了请求切换，所以我的返回语句分别是Message from IP: 192.168.102.133和Message from IP: 192.168.102.132</p><p>打两次包，把</p><p>返回信息为<strong>Message from IP: 192.168.102.132</strong>打的包放到<strong>192.168.102.132</strong>这个IP的服务器上；</p><p>返回信息为<strong>Message from IP: 192.168.102.133</strong>打的包放到<strong>192.168.102.133</strong>这个IP的服务器上；</p><p>编写完执行打包命令（可使用命令，亦可以直接在IDEA里面使用插件的打包命令，如果使用IDEA的maven插件按下图依次执行）</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924151247424.png" alt="image-20210924151247424"></p><p>然后把打包生成的war包分别上传至两台虚拟机</p><p>然后配置Nginx反向代理</p><p>在nginx.conf文件里面新增一个location配置，写入以下内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location ^~/highAvailability/ {                                    #highAvailability为你的请求前缀proxy_pass   http://192.168.102.132:9000/highAvailability/;    #你的服务地址}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如下图所示</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924151727948.png" alt="image-20210924151727948"></p><p>192.168.102.133的服务器只需把IP地址变更就行，和上面的配置一样</p><p>配置Tomcat</p><p>因为使用的是外部部署的方式，所以我们在application.yml里面配置的</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 9000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>没有效果，我们需要在安装的Tomcat里面修改Tomcat配置才有效</p><p>进入Tomcat安装目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/tomcat/apache-tomcat-9.0.53<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个webapps1文件夹，里面存放我们刚刚上传的war包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir webapps1/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入conf目录修改server.xml文件，我们需要在server.xml里面新增我们刚刚创建的webapps1配置，新增内容如下</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Service</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Catalina<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>9000<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span>               <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span>               <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Engine</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Catalina<span class="token punctuation">"</span></span> <span class="token attr-name">defaultHost</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Realm</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.catalina.realm.LockOutRealm<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Realm</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.catalina.realm.UserDatabaseRealm<span class="token punctuation">"</span></span>                   <span class="token attr-name">resourceName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UserDatabase<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Realm</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Host</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span>  <span class="token attr-name">appBase</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>webapps1<span class="token punctuation">"</span></span>              <span class="token attr-name">unpackWARs</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">autoDeploy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.catalina.valves.AccessLogValve<span class="token punctuation">"</span></span> <span class="token attr-name">directory</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logs<span class="token punctuation">"</span></span>                   <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localhost_access_log<span class="token punctuation">"</span></span> <span class="token attr-name">suffix</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.txt<span class="token punctuation">"</span></span>                   <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>%h %l %u %t <span class="token entity named-entity" title="&quot;">&amp;quot;</span>%r<span class="token entity named-entity" title="&quot;">&amp;quot;</span> %s %b<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Host</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Engine</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Service</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体如下图所示</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152425389.png" alt="image-20210924152425389"></p><p>与默认配置唯一的区别就是appBase，两台虚拟机配置一样</p><p>配置完成后重启Tomcat，Nginx,KeepAlived然后再游览器访问我们在KeepAlived配置的VIP(<strong>我设置的为192.168.102.199</strong>)地址</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152700511.png" alt="image-20210924152700511"></p><p>可以看到这时返回的是IP为192.168.102.132虚拟机服务的信息，这时我们停掉192.168.102.132虚拟机的nginx服务</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152831109.png" alt="image-20210924152831109"></p><p>再次访问发现返回信息已经变成192.168.102.133虚拟机服务返回的信息了，如下图所示</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152926940.png" alt="image-20210924152926940"></p><p>至此，我们就已经实现了服务的高可用。</p><p>文章不足之处，可以在下面评论交流</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> KeepAlived </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高可用 </tag>
            
            <tag> nginx </tag>
            
            <tag> keepalived </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫爬取豆瓣电影白蛇评论</title>
      <link href="/posts/ac3c.html"/>
      <url>/posts/ac3c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Python爬虫爬取豆瓣电影评论内容，评论时间和评论人"><a href="#Python爬虫爬取豆瓣电影评论内容，评论时间和评论人" class="headerlink" title="Python爬虫爬取豆瓣电影评论内容，评论时间和评论人"></a>Python爬虫爬取豆瓣电影评论内容，评论时间和评论人</h2><p>我们可以看到影评比较长，需要展开才能完整显示。但是在网页源码中是没有显示完整影评的。所以我们考虑到这部分应该是异步加载的方式显示。所以打开网页的开发者选项，可以看到点击展开之后，多了一条full的网页。这个网页就包含了完整评论。<br>我们观察到全部评论所在的网址为<a href="https://movie.douban.com/j/review/9593388/full">https://movie.douban.com/j/review/9593388/full</a></p><p>获取索引页<a href="https://movie.douban.com/review/best/?start=0%EF%BC%8C%E7%B4%A2%E5%BC%95%E9%A1%B5%E5%8F%AA%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98start=0,20,40%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE%E4%B8%8B%E4%B8%80%E9%A1%B5">https://movie.douban.com/review/best/?start=0，索引页只需要改变start=0,20,40即可访问下一页</a><br>解析索引页，把索引页中的10个评论的ID获取到<br>通过获取到的ID构建完整评论网址<a href="https://movie.douban.com/j/review/'">https://movie.douban.com/j/review/'</a> + str(id) + ‘/full<br>解析评论页，获取评论者姓名和评论内容，写入txt文件<br>附上源码：</p><pre class="line-numbers language-none"><code class="language-none">import urllib.requestimport recomment = '白蛇.txt'T='&lt;span content=".*?" class=".*?"&gt;.*?&lt;/span&gt;'for i in range(10):    print("获取第"+str(i+1)+"页")    url = "https://movie.douban.com/subject/30331149/reviews?start="+str(i*20)  # 确定要爬取的入口链接     # 模拟成浏览器并爬取对应的网页 谷歌浏览器    headers = {'User-Agent',               'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36'}    opener = urllib.request.build_opener()    opener.addheaders = [headers]    data = opener.open(url).read().decode('utf8')    time_pattern = re.compile('&lt;span content=".*?" class=".*?"&gt;(.*?)&lt;/span&gt;', re.S)    time = re.findall(time_pattern, data)    id_pattern= re.compile('&lt;h2&gt;&lt;a href="https://movie.douban.com/review/(.*?)/', re.S)    id= re.findall(id_pattern, data)    for j in range(len(id)):        html = 'https://movie.douban.com/j/review/' + str(id[j]) + '/full'        data = opener.open(html).read().decode('utf8')        html = data        content_pattern = re.compile('data-original(.*?)main-author', re.S)        content = re.findall(content_pattern, html)        text_pattern = re.compile('[\u4e00-\u9fa5|，、“”‘’：！~@#￥【】*（）——+。；？]+', re.S)        text = re.findall(text_pattern, content[0])        text = ''.join(text)        name_pattern = re.compile('data-author=.*?"(.*?)"', re.S)        name = re.findall(name_pattern, html)        with open(comment, 'a', encoding='utf-8-sig') as f:            f.write(name[0].strip('\\') + '\n')            f.write(time[j]+'\n')            f.write(str(text) + '\n')            f.write('\n')            f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 豆瓣 </tag>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫爬取淘宝商品信息</title>
      <link href="/posts/4818.html"/>
      <url>/posts/4818.html</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫爬取淘宝商品信息"><a href="#爬虫爬取淘宝商品信息" class="headerlink" title="爬虫爬取淘宝商品信息"></a>爬虫爬取淘宝商品信息</h2><p>前面已经写过一篇获取淘宝信息的文章，但是那篇文章并没有获取商品详情页下面的信息，也没有数据保存功能，这篇文章就是在上篇文章上增加了商品详情页信息的获取和数据保存为xls文件，原理和上一篇文章一样，故不做过多介绍，想看看原理的请看上一篇博客，博客传送门<a href="https://blog.csdn.net/qq_43764365/article/details/103539728">爬虫爬取京东和淘宝商品信息</a>。不明白的老规矩，评论区留言讨论或者加QQ2511217211（加Q请备注讨论，否则不予通过）。<br>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># coding=UTF-8from selenium import webdriverfrom time import sleepimport randomimport reimport osimport xlrdimport xlwtfrom xlutils.copy import copy# 获取页码def search_products():    driver.find_element_by_xpath('//*[@id="q"]').send_keys(keyword)    driver.find_element_by_xpath('//*[@id="J_TSearchForm"]/div[1]/button').click()    sleep(60)    token = driver.find_element_by_xpath('//*[@id="mainsrp-pager"]/div/div/div/div[1]').text    # 0代表所有匹配到的数字    token = int(re.compile('(\d+)').search(token).group(1))    return token# 下拉下滑条，加载数据def drop_down():    for x in range(1, 11, 2):        sleep(1)        j = x / 10        js = 'document.documentElement.scrollTop = document.documentElement.scrollHeight * %f' % j        driver.execute_script(js)# 获取商品信息def get_product(page):    oldHandle = driver.window_handles    lis = driver.find_elements_by_xpath('//div[@class="items"]/div[@class="item J_MouserOnverReq  "]')    for i in range(len(lis)):        print("获取第{}页第{}条中...".format(page, i + 1))        li = driver.find_elements_by_xpath('//div[@class="items"]/div[@class="item J_MouserOnverReq  "]')[i]        sales = ''        # 商品信息        info = li.find_element_by_xpath('.//div[@class="row row-2 title"]').text        # 价格        price = li.find_element_by_xpath('.//a[@class="J_ClickStat"]').get_attribute('trace-price')        # 付款人数        deal = li.find_element_by_xpath('.//div[@class="deal-cnt"]').text        # 只留数字,便于数据分析        deal = int(re.compile('(\d+)').search(deal).group(1))        # 封面图片地址        image = li.find_element_by_xpath('.//div[@class="pic"]/a/img').get_attribute('src')        # 商家名称        name = li.find_element_by_xpath('.//div[@class="shop"]/a/span[2]').text        # 商家地址        site = li.find_element_by_xpath('.//div[@class="location"]').text        # 详情页地址        href = li.find_element_by_xpath('.//a[@class="J_ClickStat"]').get_attribute('href')        li.click()        handles = driver.window_handles        handle = list(set(oldHandle) ^ set(handles))        oldHandle = list(set(oldHandle) &amp; set(handles))        driver.switch_to.window(handle[0])        storeType = href[8:].split('/')[0]        if storeType == 'detail.tmall.com':            # 店铺在天猫上            sales = driver.find_element_by_xpath(                '//*[@id="J_DetailMeta"]/div[1]/div[1]/div/ul/li[1]/div/span[2]').text        elif storeType == 'item.taobao.com':            # 店铺在淘宝上            sales = driver.find_element_by_xpath('//*[@id="J_SellCounter"]').text        else:            # 既不是天猫也不是淘宝直接跳过            pass        # 月销量        sales = int(re.compile('(\d+)').search(sales).group(1))        # 月销额        monthlySales = sales * float(price)        flag = MakeRandomNumbers(1, 100)        if flag % 3 == 0 or flag % 8 == 0:            drop_down()        # 随机睡眠10~20秒,接口有防盗刷        markAmount = MakeRandomNumbers(i, len(lis)) % 10        sleep(MakeRandomNumbers(5 * markAmount, 20 * markAmount))        driver.close()        driver.implicitly_wait(10)        driver.switch_to.window(oldHandle[0])        value = [[info, price, deal, name, site, sales, monthlySales], ]        write_excel_xls_append(book_name_xls, value)        # print(info, price, deal, name, site, sales, monthlySales, image, sep='|')# 生成随机数def MakeRandomNumbers(a, b):    return random.randint(a, b)# 随机休眠def dormancy(a, b):    sleep(random.randint(a, b))# 翻页def next_page():    token = search_products()    num = 0    while num != token:        dormancy(60, 120)  # 随机休眠一到两分钟        driver.get('https://s.taobao.com/search?q={}&amp;s={}'.format(keyword, 44 * num))        driver.implicitly_wait(10)        num += 1        drop_down()        get_product(num)# 创建Excel数据表并写入表头数据def write_excel_xls_head(path, sheet_name, value):    index = len(value)  # 获取需要写入数据的行数    workbook = xlwt.Workbook()  # 新建一个工作簿    sheet = workbook.add_sheet(sheet_name)  # 在工作簿中新建一个表格    for i in range(0, index):        for j in range(0, len(value[i])):            sheet.write(i, j, value[i][j])  # 像表格中写入数据（对应的行和列）    workbook.save(path)  # 保存工作簿    print("表头写入成功！")# 写入表格数据def write_excel_xls_append(path, value):    index = len(value)  # 获取需要写入数据的行数    workbook = xlrd.open_workbook(path)  # 打开工作簿    sheets = workbook.sheet_names()  # 获取工作簿中的所有表格    worksheet = workbook.sheet_by_name(sheets[0])  # 获取工作簿中所有表格中的的第一个表格    rows_old = worksheet.nrows  # 获取表格中已存在的数据的行数    new_workbook = copy(workbook)  # 将xlrd对象拷贝转化为xlwt对象    new_worksheet = new_workbook.get_sheet(0)  # 获取转化后工作簿中的第一个表格    for i in range(0, index):        for j in range(0, len(value[i])):            new_worksheet.write(i + rows_old, j, value[i][j])  # 追加写入数据，注意是从i+rows_old行开始写入    new_workbook.save(path)  # 保存工作簿if __name__ == "__main__":    book_name_xls = '淘宝商品数据.xls'    sheet_name_xls = '商品数据表'    value_title = [["商品信息", "价格", "付款人数", "商家名称", "商家地址", "月销量", "月销金额"], ]    write_excel_xls_head(book_name_xls, sheet_name_xls, value_title)    driver_path = os.path.abspath(os.path.join(os.getcwd(), ".")) + "/dr/chromedriver.exe"    keyword = input('输入你想查找的商品名字:')    options = webdriver.ChromeOptions()    # options.add_argument("--no-sandbox")    # options.add_argument('lang=zh_CN.UTF-8')    options.add_argument('--start-maximized')    # options.add_argument("--headless") 无界面模式 options.add_argument('user-agent="Mozilla/5.0 (Windows NT 10.0; Win64;    # x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36"')    # options.add_experimental_option("prefs", {"profile.managed_default_content_settings.images": 2})  # 不加载图片,加快访问速度    options.add_experimental_option('excludeSwitches', ['enable-automation'])  # 此步骤很重要，设置为开发者模式，防止被各大网站识别出来使用了Selenium    driver = webdriver.Chrome(executable_path=driver_path, options=options)    driver.get('https://www.taobao.com/')    next_page()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存的数据文件截图<br><img src="https://img-blog.csdnimg.cn/20210531112941554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzY0MzY1,size_16,color_FFFFFF,t_70" alt="数据"><br>文章只是一种学习方法，效率不是很高，要追求效率老老实实抓包分析，然后伪造请求，改分页参数一次性就可以获取几百条。但是那样的难度上升的层级不止一点半点。有兴趣的可以在评论区讨论。<br><strong>声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 淘宝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/a2d2.html"/>
      <url>/posts/a2d2.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h1></blockquote><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><p>同一个类的不同对象的Hash Code不同</p></li><li><p>形容词用接口，名词用抽象类</p></li><li><p>设计模式常用的七大原则</p><ol><li><p><strong>单一职责原则：控制类的颗粒度大小、将对象解耦、提高其内聚性</strong></p><p><strong>基本介绍</strong></p><p>对类来说，即一个类应该只负责意向职责。</p><p><strong>注意事项和细节</strong></p><ol><li>降低类的复杂度，一个类只负责一项职责</li><li>提高类的可读性、可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol></li><li><p><strong>接口隔离原则：要为各个类建立它们需要的专用接口</strong></p><p><strong>基本介绍</strong></p><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><p><strong>应传统方法的问题和使用接口隔离原则改进</strong></p><ol><li>类A通过接口interface1依赖类B，类C通过接口interfa1依赖类D，如果接口interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法</li><li>将接口interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</li><li>接口interface1中出现的方法，根据实际情况拆分为三个接口</li><li>代码实现</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829095930685.png" alt="image-20210829095930685"></p></li><li><p><strong>依赖倒转原则：要面向接口编程，不要面向实现编程</strong></p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转（倒置）的中心思想是面向接口编程</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829102317701.png" alt="image-20210829102317701.png"></p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829102400935.png" alt="image-20210829102400935"></p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829102515810.png" alt="image-20210829102515810"></p></li><li><p><strong>里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立</strong></p><p><strong>OO中的继承性的思考和说明</strong></p><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时，也带来了弊端。比如原来使用继承会给其他程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。</li><li>问题提出：在编程中，如何正确的使用继承？——————————————————&gt;里氏替换原则</li></ol><p><strong>里氏替换原则基本介绍</strong></p><ol><li>里氏替换原则在1988年，有麻省理工学院的一位姓里的女士提出的。</li><li>如果对每个类型为T1的对象O1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1都代换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句换说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</li><li>里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</li></ol></li><li><p><strong>开闭原则(Open Closed Principle):对扩展开放，对修改关闭</strong></p><p><strong>基本介绍</strong></p><ol><li>是编程中最基础、最重要的设计原则</li><li>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</li></ol></li><li><p><strong>迪米特法则：只跟你的直接朋友交谈，不跟“陌生人”说话</strong></p><p><strong>基本介绍</strong></p><ol><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li><li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li></ol><p><strong>迪米特法则注意事项和细节</strong></p><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</li></ol></li><li><p><strong>合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong></p><p><strong>基本介绍</strong></p><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210912221606552.png" alt="image-20210912221606552"></p></li></ol></li><li><p><strong>设计原则核心思想</strong></p><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li></ol></li><li><p><strong>UML基本介绍</strong></p><ol><li>UML(Unified modeling language UML) 统一建模语言，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</li><li>UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</li><li>使用UML来建模，常用的工具有Rational Rose , 也可以使用一些插件来建模</li></ol><p><strong>分类：</strong></p><ol><li>用例图(use case)</li><li>静态结构图：类图、对象图、包图、组件图、部署图</li><li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li></ol></li></ul><h3 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h3><ol><li><strong>创建型模式：</strong>单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li></ol><ol start="2"><li>   <strong>结构型模式：</strong>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li><li>   <strong>行为型模式：</strong>模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li>单例：单个实例</li><li>应用场景：只需要一个实例存在（如：各种manager，各种factory等）</li><li>保证实例在内存中只有一个实例定义一个static final 实例 INSTANCE；例如（private static final Mgr01 INSTANCE = new Mgr01();）</li><li>注意：单例模式需要防止反序列化（Java的反射可以通过实例.class漏到内存中，然后再new一个实例出来，enum可以防止反序列化，能防止的原因是因为enum没有构造方法，就算拿到class文件也无法构造对象，它的反序列化返回的只是一个（INSTANCE）值）</li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul><li><p>策略模式封装的是做一件事情时不同的执行方式</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210717181341796.png" alt="策略模式类图"></p></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul><li>工厂：任何可以产生对象的方法或类，都可以称之为工厂</li><li>单例也是一种工厂</li><li>为什么有了new之后，还要有工厂？<ul><li>灵活控制生产过程</li><li>权限、修饰、日志…</li></ul></li><li>工厂分类：<ol><li><p>简单工厂</p><p><strong>介绍：</strong></p><ol><li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式</li></ol><ol start="2"><li>   简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</li><li>   在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210920132453696.png" alt="image-20210920132453696"></p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210920132657337.png" alt="image-20210920132657337"></p></li><li><p>静态工厂</p></li><li><p>工厂方法FactoryMethod</p><ul><li>产品维度扩展</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210920132747104.png" alt="image-20210920132747104"></p></li><li><p>抽象工厂</p><p><strong>介绍：</strong></p><ol><li>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类</li></ol><ol start="2"><li>   抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li><li>   从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li><li>   将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li><li>   类图</li></ol><ul><li>产品一族扩展</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210920132811213.png" alt="image-20210920132811213"></p><p><strong>工厂模式的意义：</strong></p><ol><li>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</li><li>三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)</li><li>设计模式的依赖抽象原则</li></ol><p><strong>注意事项：</strong></p><ul><li>创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现interface(接口)</li><li>不要覆盖基类中已经实现的方法。</li></ul></li></ol></li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>介绍：</strong></p><ol><li>原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li></ol><ol start="2"><li>   原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li>   工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()</li><li>   形象的理解：孙大圣拔出猴毛，变出其它孙大圣</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210921111815387.png" alt="image-20210921111815387"></p><ul><li>Prototype : 原型类，声明一个克隆自己的接口</li><li>ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作</li><li>Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)</li></ul><p><strong>浅拷贝：</strong></p><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li></ul><ol start="2"><li>   对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>   前面我们克隆羊就是浅拷贝</li></ol><ul><li>浅拷贝是使用默认的clone()方法来实现sheep = (Sheep) super.clone();</li></ul><p><strong>深拷贝：</strong></p><ul><li>复制对象的所有基本数据类型的成员变量值</li></ul><ol start="2"><li>   为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝</li><li>   深拷贝实现方式1：重写clone方法来实现深拷贝</li><li>   深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)</li></ol><p><strong>原型模式的注意事项和细节：</strong></p><ul><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li></ul><ol start="2"><li>   不用重新初始化对象，而是动态地获得对象运行时的状态</li><li>   如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>   在实现深克隆的时候可能需要比较复杂的代码</li><li>   缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。</li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ul><li><p><strong>建造者模式介绍：</strong></p><ol><li>建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</li></ol><ol start="2"><li>   建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ol></li><li><p><strong>建造者模式的四个角色：</strong></p><ol><li>Product（产品角色）：一个具体的产品对象。</li></ol><ol start="2"><li>   Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口/抽象类。</li><li>   ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。</li><li>   Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210921203121854.png" alt="image-20210921203121854"></p></li><li><p><strong>建造者模式的注意事项和细节：</strong></p><ol><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象</li><li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li><li>抽象工厂模式VS建造者模式<br>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</li></ol></li></ul><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul><li><p><strong>适配器模式基本介绍</strong></p><ol><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于结构型模式</li><li>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</li></ol></li><li><p><strong>适配器模式工作原理</strong></p><ol><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li></ol><ol start="2"><li>   从用户的角度看不到被适配者，是解耦的</li><li>   用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>   用户收到反馈结果，感觉只是和目标接口交互，如图</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210922211015198.png" alt="image-20210922211013143"></p></li><li><p><strong>类适配器模式：</strong></p><ul><li><p>基本介绍：</p><p>Adapter类，通过继承src类，实现dst 类接口，完成src-&gt;dst的适配</p></li><li><p>类适配器模式注意事项和细节：</p><ol><li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst必须是接口，有一定局限性;</li></ol><ol start="2"><li>   src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li><li>   由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。</li></ol></li></ul></li><li><p><strong>对象适配器模式</strong></p><ul><li>基本介绍<ol><li>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口，完成src-&gt;dst的适配</li></ol><ol start="2"><li>   根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。</li><li>   对象适配器模式是适配器模式常用的一种</li></ol></li><li>对象适配器模式注意事项和细节<ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。</li></ol><ol start="2"><li>   使用成本更低，更灵活。</li></ol></li></ul></li><li><p><strong>接口适配器模式</strong></p><ul><li>基本介绍<ol><li>一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。</li></ol><ol start="2"><li>   当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li><li>   适用于一个接口不想使用其所有的方法的情况。</li></ol></li><li>适配器模式的注意事项和细节<ol><li>   三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。</li></ol><ol start="2"><li>类适配器：以类给到，在Adapter里，就是将src当做类，继承对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</li></ol><ol start="3"><li>   Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</li></ol></li></ul></li></ul><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><ul><li>基本介绍<ol><li>桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li></ol><ol start="2"><li>   是一种结构型设计模式</li></ol><ol start="3"><li>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</li></ol></li><li>原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210923142733407.png" alt="image-20210923142731463"></p><ul><li><p>原理类图说明</p><ol><li>Client类：桥接模式的调用者</li></ol><ol start="2"><li>   抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当桥接类</li></ol><ol start="3"><li>RefinedAbstraction：是Abstraction抽象类的子类</li><li>Implementor：行为实现类的接口</li><li>ConcreteImplementorA/B：行为的具体实现类</li><li>从UML图看出：这里的抽象类和接口是聚合关系，其实也是调用和被调用的关系</li></ol></li><li><p>桥接模式的注意事项和细节</p><ol><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li></ol><ol start="2"><li>   对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</li><li>   桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li><li>   桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>   桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li></ol></li><li><p>桥接模式其它应用场景</p><ol><li><p>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.</p></li><li><p>常见的应用场景:</p><ul><li><p>JDBC驱动程序</p></li><li><p>银行转账系统<br>转账分类: 网上转账，柜台转账，AMT转账<br>转账用户类型：普通用户，银卡用户，金卡用户..</p></li><li><p>消息管理<br>消息类型：即时消息，延时消息<br>消息分类：手机短信，邮件消息，QQ消息…</p></li></ul></li></ol></li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><ul><li><p>基本介绍</p><p>装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p></li><li><p>装饰者模式(Decorator)原理</p><ol><li>装饰者模式就像打包一个快递<ul><li>主体：比如：陶瓷、衣服 (Component) // 被装饰者</li><li>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)</li></ul></li><li>Component<ul><li>主体：比如类似前面的Drink</li></ul></li><li>ConcreteComponent和Decorator ConcreteComponent：<ul><li>具体的主体，比如前面的各个单品咖啡</li><li>Decorator: 装饰者，比如各调料</li></ul></li><li>在如图的Component与ConcreteComponent之间，如果ConcreteComponent类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。</li></ol></li></ul><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ul><li>基本介绍<ol><li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。</li></ol><ol start="2"><li>   组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</li><li>   这种类型的设计模式属于结构型模式。</li><li>   组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</li></ol></li><li>组合模式原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210925133818552.png" alt="image-20210925133818552"></p><p><strong>对原理结构图的说明-即(组合模式的角色及职责)</strong></p><ol><li>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component子部件,Component可以是抽象类或者接口</li><li>Leaf:在组合中表示叶子节点，叶子节点没有子节点</li><li>Composite :非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加(add),删除。</li></ol><p><strong>组合模式解决的问题</strong></p><ol><li>   组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子</li><li>   对应的示意图</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210925134428999.png" alt="image-20210925134428999"></p><p><strong>组合模式的注意事项和细节</strong></p><ol><li>   简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li><li>   具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.</li><li>   方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构</li><li>   需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.</li><li>   要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</li></ol><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><ul><li>基本介绍<ol><li>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li></ol><ol start="2"><li>   外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</li></ol></li><li>外观模式原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210925171816732.png" alt="image-20210925171816732"></p><p><strong>原理类图的说明(外观模式的角色)</strong></p><ol><li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象</li><li>调用者(Client): 外观接口的调用者</li><li>子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者</li></ol><p><strong>外观模式的注意事项和细节</strong></p><ol><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</li></ol><ol start="2"><li>   外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</li><li>   通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li><li>   当系统需要进行分层设计时，可以考虑使用Facade模式</li><li>   在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</li><li>   不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</li></ol><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><ul><li>基本介绍<ol><li>享元模式（Flyweight Pattern）也叫蝇量模式: 运用共享技术有效地支持大量细粒度的对象</li></ol><ol start="2"><li>   常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li><li>   享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li><li>   享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</li></ol></li><li>享元模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210926094451719.png" alt="image-20210926094451719"></p><p><strong>对原理图的说明-即(模式的角色及职责)</strong></p><ol><li>FlyWeighit 是抽象的享元角色，他是产品的抽象类,同时定义出对象的外部状态和内部状态(后面介绍)的接口或实现</li><li>ConcreteFlyWeight是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li><li>UnSharedConcreteFlyWeight是不可共享的角色，一般不会出现在享元工厂</li><li>FlyWeightFactory享元工厂类，用于构建一个池容器(集合)，同时提供从池中获取对象方法</li></ol><p><strong>内部状态和外部状态</strong></p><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p><ol><li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态</li></ol><ol start="2"><li>   内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li><li>   外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态</li><li>   举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</li></ol><p><strong>享元模式的注意事项和细节</strong></p><ol><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li></ol><ol start="2"><li>   系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>   用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储</li><li>   享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li><li>   享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.</li><li>   使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制</li><li>   享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池</li></ol><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul><li>基本介绍<ol><li>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</li></ol><ol start="2"><li>   被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</li><li>   代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK代理、接口代理)和 Cglib代理(可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴) 。</li><li>   代理模式示意图</li></ol></li><li>静态代码模式的基本介绍</li></ul><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类</p><ul><li>静态代理优缺点<ol><li>优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展</li></ol><ol start="2"><li>   缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</li><li>   一旦接口增加方法,目标对象与代理对象都要维护</li></ol></li><li>动态代理模式的基本介绍</li></ul><ol><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li></ol><ol start="2"><li>   代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</li><li>   动态代理也叫做：JDK代理、接口代理</li></ol><ul><li>Cglib代理模式的基本介绍</li></ul><ol><li>静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理</li></ol><ol start="2"><li>   Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。</li><li>   Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截</li></ol><ol start="4"><li>在AOP编程中如何选择代理模式：<ol><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理</li></ol></li></ol><ol start="5"><li>   Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</li></ol><ul><li>代理模式(Proxy)的变体</li></ul><ol><li><p><strong>防火墙代理</strong><br>内网通过代理穿透防火墙，实现对公网的访问。</p></li><li><p><strong>缓存代理</strong><br>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源，再到公网或者数据库取，然后缓存。</p></li><li><p><strong>远程代理</strong><br>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210926142008139.png" alt="image-20210926142008139"></p></li><li><p><strong>同步代理</strong></p><p>主要使用在多线程编程中，完成多线程间同步工作</p></li></ol><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul><li>基本介绍<ol><li>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，z在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行</li></ol><ol start="2"><li>   简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li><li>   这种类型的设计模式属于行为型模式</li></ol></li><li>模板方法模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210928101823955.png" alt="image-20210928101823955"></p><p><strong>对原理类图的说明-即(模板方法模式的角色及职责)</strong></p><ol><li>AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现 其它的抽象方法operationr2,3,4</li></ol><ol start="2"><li>   ConcreteClass 实现抽象方法operationr2,3,4, 以完成算法中特点子类的步骤</li></ol><ul><li>模板方法模式的注意事项和细节<ol><li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li></ol><ol start="2"><li>   实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。</li><li>   既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li><li>   该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大</li><li>   一般模板方法都加上final关键字， 防止子类重写模板方法.</li><li>   模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理</li></ol></li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul><li><p>基本介绍</p><ol><li>命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</li><li>命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。</li><li>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。</li><li>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。Invoker是调用者（将军），Receiver是被调用者（士兵）， MyCommand是命令，实现了Command接口，持有接收对象</li></ol></li><li><p>命令模式的原理类图</p></li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210928142323399.png" alt="image-20210928142323399"></p><ul><li>对原理类图的说明-即(命名模式的角色及职责)<ol><li>Invoker 是调用者角色</li></ol><ol start="2"><li>   Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类</li><li>   Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作</li><li>   ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute</li></ol></li><li>命令模式的注意事项和细节<ol><li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：” 请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。</li></ol><ol start="2"><li>   容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令</li><li>   容易实现对请求的撤销和重做</li><li>   命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意</li><li>   空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li><li>   命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令）订单的撤销/恢复、触发-反馈机制</li></ol></li></ul><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><ul><li>基本介绍<ol><li>访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li></ol><ol start="2"><li>   主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题</li><li>   访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口</li><li>   访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作”污染”这些对象的类，可以选用访问者模式解决</li></ol></li><li>访问者模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210928153304474.png" alt="image-20210928153304474"></p><ul><li>对原理类图的说明-即(访问者模式的角色及职责)<ol><li>Visitor 是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作</li></ol><ol start="2"><li>   ConcreteVisitor ：是一个具体的访问值 实现每个由Visitor 声明的操作，是每个操作实现的部分.</li><li>   ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素</li><li>   Element 定义一个accept 方法，接收一个访问者对象</li><li>   ConcreteElement 为具体元素，实现了accept 方法</li></ol></li><li>访问者模式的注意事项和细节<ul><li>优点<ol><li>访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高</li></ol><ol start="2"><li>   访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li></ol></li><li>缺点<ol><li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造成了具体元素变更比较困难</li></ol><ol start="2"><li>   违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li><li>   因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的</li></ol></li></ul></li></ul><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><ul><li>基本介绍<ol><li>迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式</li></ol><ol start="2"><li>   如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</li><li>   迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。</li></ol></li><li>迭代器模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210928162918581.png" alt="image-20210928162918581"></p><ul><li>对原理类图的说明-即(迭代器模式的角色及职责)<ol><li>Iterator :迭代器接口，是系统提供，含义hasNext, next, remove</li><li>Concretelterator:具体的迭代器类，管理迭代</li><li>Aggregate :一个统一的聚合接口，将客户端和具体聚合解耦</li><li>ConcreteAggreage :具体的聚合持有对象集合，并提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合</li><li>Client :客户端，通过Iterator和Aggregate 依赖子类</li></ol></li><li>迭代器模式的注意事项和细节<ul><li>优点<ol><li>提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。</li></ol><ol start="2"><li>   隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。</li><li>   提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。</li><li>   当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式</li></ol></li><li>缺点<ol><li>每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类</li></ol></li></ul></li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><ul><li><p>基本介绍</p><p>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是Subject，是1的一方。用户时Observer，是多的一方。</p></li><li><p>观察者模式原理</p><ul><li><p>观察者模式类似订牛奶业务</p><ol><li>奶站/气象局：Subject</li><li>用户/第三方网站：Observer</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210929085513241.png" alt="image-20210929085513241"></p></li><li><p>Subject：登记注册、移除和通知</p><ol><li>registerObserver 注册</li><li>removeObserver 移除</li><li>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送，看具体需求定</li><li>Observer：接收输入</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210929085527412.png" alt="image-20210929085527412"></p></li><li><p>思路分析图解(类图)</p></li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210929085607045.png" alt="image-20210929085607045"></p></li></ul><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><ul><li><p>基本介绍</p><ol><li>中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li></ol><ol start="2"><li>   中介者模式属于行为型模式，使代码易于维护</li><li>   比如MVC模式，C（Controller控制器）是M（Model模型）和V（View视图）的中介者，在前后端交互时起到了中间人的作用</li></ol></li><li><p>中介者模式的原理类图</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210929102215528.png" alt="image-20210929102215528"></p><ul><li>对原理类图的说明-即(中介者模式的角色及职责)<ol><li>Mediator就是抽象中介者,定义了同事对象到中介者对象的接口</li><li>Colleague是抽象同事类</li><li>ConcreteMediator 具体的中介者对象，实现抽象方法，他需要知道所有的具体的同事类,即以一个集合来管理HashMap,并接受某个同事对象消息，完成相应的任务</li><li>ConcreteColleague具体的同事类，会有很多,每个同事只知道自己的行为，而不了解其他同事类的行为(方法)，但是他们都依赖中介者对象</li></ol></li></ul></li><li><p>中介者模式的注意事项和细节</p><ol><li>多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦</li></ol><ol start="2"><li>   减少类间依赖，降低了耦合，符合迪米特原则</li><li>   中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li><li>   如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</li></ol></li></ul><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><ul><li>基本介绍<ol><li>备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</li></ol><ol start="2"><li>   可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作</li><li>   备忘录模式属于行为型模式</li></ol></li><li>备忘录模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210929113937563.png" alt="image-20210929113937563"></p><ul><li>对原理类图的说明-即(备忘录模式的角色及职责)<ol><li>originator : 对象(需要保存状态的对象)</li><li>Memento ： 备忘录对象,负责保存好记录，即Originator内部状态</li></ol><ol start="3"><li>   Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效率</li><li>   说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要要 HashMap &lt;String, 集合&gt;</li></ol></li><li>备忘录模式的注意事项和细节<ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li></ol><ol start="2"><li>   实现了信息的封装，使得用户不需要关心状态的保存细节</li><li>   如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意</li><li>   适用的应用场景：1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理</li><li>   为了节约内存，备忘录模式可以和原型模式配合使用</li></ol></li></ul><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><ul><li>基本介绍<ol><li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器</li><li>解释器模式（Interpreter Pattern）：是指给定一个语言(表达式)，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)</li><li>应用场景<ul><li>应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li><li>一些重复出现的问题可以用一种简单的语言来表达</li><li>一个简单语法需要解释的场景</li></ul></li><li>这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等</li></ol></li><li>解释器模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210929135821763.png" alt="image-20210929135821763"></p><ul><li>对原理类图的说明-即(解释器模式的角色及职责)<ol><li>Context: 是环境角色,含有解释器之外的全局信息.</li></ol><ol start="2"><li>   AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所共享</li><li>   TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作</li><li>   NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作.</li><li>   说明： 输入Context he TerminalExpression 信息通过Client 输入即可</li></ol></li><li>解释器模式的注意事项和细节<ol><li>当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性</li></ol><ol start="2"><li>   应用场景：编译器、运算表达式计算、正则表达式、机器人等</li><li>   使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低</li></ol></li></ul><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><ul><li>基本介绍<ol><li>状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换</li></ol><ol start="2"><li>   当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类</li></ol></li><li>状态模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210930083715769.png" alt="image-20210930083715769"></p><ul><li>对原理类图的说明-即(状态模式的角色及职责)<ol><li>Context 类为环境角色, 用于维护State实例,这个实例定义当前状态</li></ol><ol start="2"><li>   State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为</li><li>   ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为</li></ol></li><li>状态模式的注意事项和细节<ol><li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li></ol><ol start="2"><li>   方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错</li><li>   符合“开闭原则”。容易增删状态</li><li>   会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度</li><li>   应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式</li></ol></li></ul><h3 id="策略模式-1"><a href="#策略模式-1" class="headerlink" title="策略模式"></a>策略模式</h3><ul><li>基本介绍<ol><li>策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</li></ol><ol start="2"><li>   这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）</li></ol></li><li>策略模式的原理类图</li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210930083901577.png" alt="image-20210930083901577"></p><p>从上图可以看到，客户context 有成员变量strategy或者其他的策略接口 ,至于需要使用到哪个策略，我们可以在构造器中指定</p><ul><li>策略模式的注意事项和细节<ol><li>策略模式的关键是：分析项目中变化部分与不变部分</li></ol><ol start="2"><li>   策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性</li><li>   体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else）</li><li>   提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展</li><li>   需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li></ol></li></ul><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><ul><li><p>基本介绍</p><ol><li><p>职责链模式（Chain of Responsibility Pattern）,又叫责任链模式，为请求创建了一个接收者对象的链(简单示意图)。这种模式对请求的发送者和接收者进行解耦。</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210930084056371.png" alt="image-20210930084056371"></p></li><li><p>职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p></li><li><p>这种类型的设计模式属于行为型模式</p></li></ol></li><li><p>职责链模式的原理类图</p></li></ul><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210930084141204.png" alt="image-20210930084141204"></p><p>职责链模式（Chain Of Responsibility），使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><ul><li>对原理类图的说明-即(职责链模式的角色及职责)<ol><li>Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler</li></ol><ol start="2"><li>   ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处理者), 如果可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链</li><li>   Request ， 含义很多属性，表示一个请求</li></ol></li><li>职责链模式的注意事项和细节<ol><li>将请求和处理分开，实现解耦，提高系统的灵活性</li></ol><ol start="2"><li>   简化了对象，使对象不需要知道链的结构</li><li>   性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li><li>   调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li><li>   最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

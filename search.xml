<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx+KeepAlived实现服务高可用</title>
      <link href="/posts/20ce.html"/>
      <url>/posts/20ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-keepAlived实现服务高可用"><a href="#Nginx-keepAlived实现服务高可用" class="headerlink" title="Nginx + keepAlived实现服务高可用"></a>Nginx + keepAlived实现服务高可用</h1><h2 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h2><p>​        <em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为<a href="https://baike.baidu.com/item/%E4%BF%84%E7%BD%97%E6%96%AF/125568">俄罗斯</a>访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>​        其将<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3814213">源代码</a>以类<a href="https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E8%AF%81/10642412">BSD许可证</a>的形式发布，因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而<a href="https://baike.baidu.com/item/%E9%97%BB%E5%90%8D/2303308">闻名</a>。2011年6月1日，nginx 1.0.4发布。</p><p>​        Nginx是一款<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835">轻量级</a>的<a href="https://baike.baidu.com/item/Web/150564">Web</a> 服务器/<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>服务器及<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106">电子邮件</a>（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806">并发</a>能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、<a href="https://baike.baidu.com/item/%E4%BA%AC%E4%B8%9C/210931">京东</a>、<a href="https://baike.baidu.com/item/%E6%96%B0%E6%B5%AA/125692">新浪</a>、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%98%93/185754">网易</a>、<a href="https://baike.baidu.com/item/%E8%85%BE%E8%AE%AF/112204">腾讯</a>、<a href="https://baike.baidu.com/item/%E6%B7%98%E5%AE%9D/145661">淘宝</a>等。<a href="https://baike.baidu.com/item/nginx/3817705?fr=aladdin">描述来源百度百科</a></p><h2 id="什么是高可用？"><a href="#什么是高可用？" class="headerlink" title="什么是高可用？"></a>什么是高可用？</h2><p>​        “高可用性”HA（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。如果一个系统能够一直提供服务，那么这个可用性则是百分之百，但是天有不测风云。所以我们只能尽可能的去减少服务的故障。</p><h2 id="什么是KeepAlived？"><a href="#什么是KeepAlived？" class="headerlink" title="什么是KeepAlived？"></a>什么是KeepAlived？</h2><h3 id="KeepAlived简介"><a href="#KeepAlived简介" class="headerlink" title="KeepAlived简介"></a>KeepAlived简介</h3><p>​        KeepAlived是Linux下一个轻量级别的高可用解决方案。高可用(High Avalilability,HA)，其实两种不同的含义：广义来讲，是指整个系统的高可用行，狭义的来讲就是之主机的冗余和接管，它与HeartBeat RoseHA 实现相同类似的功能，都可以实现服务或者网络的高可用，但是又有差别，HeartBeat是一个专业的、功能完善的高可用软件，它提供了HA 软件所需的基本功能，比如：心跳检测、资源接管，检测集群中的服务，在集群节点转移共享IP地址的所有者等等。HeartBeat功能强大，但是部署和使用相对比较麻烦，与HeartBeat相比，KeepAlived主要是通过虚拟路由冗余来实现高可用功能，虽然它没有HeartBeat功能强大，但是KeepAlived部署和使用非常的简单，所有配置只需要一个配置文件即可以完成。</p><h3 id="VRRP协议与工作原理"><a href="#VRRP协议与工作原理" class="headerlink" title="VRRP协议与工作原理"></a>VRRP协议与工作原理</h3><p>​        在现实的网络环境中。主机之间的通信都是通过配置静态路由或者(默认网关)来完成的，而主机之间的路由器一旦发生故障，通信就会失效，因此这种通信模式当中，路由器就成了一个单点瓶颈，为了解决这个问题，就引入了VRRP协议。</p><p>​        熟悉网络的学员对VRRP协议应该不陌生，它是一种主备模式的协议，通过VRRP可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信，这其中涉及到两个概念：物理路由器和虚拟路由器。</p><p>​        VRRP可以将两台或者多台物理路由器设备虚拟成一个虚拟路由，这个虚拟路由器通过虚拟IP（一个或者多个)对外提供服务，而在虚拟路由器内部十多个物理路由器协同工作，同一时间只有一台物理路由器对外提供服务，这台物理路由设备被成为：主路由器（Master角色)，一般情况下Master是由选举算法产生，它拥有对外服务的虚拟IP，提供各种网络功能，如：ARP请求，ICMP 数据转发等，而且其它的物理路由器不拥有对外的虚拟IP，也不提供对外网络功能，仅仅接收MASTER的VRRP状态通告信息，这些路由器被统称为“BACKUP的角色”，当主路由器失败时，处于BACKUP角色的备份路由器将重新进行选举，产生一个新的主路由器进入MASTER角色，继续提供对外服务，整个切换对用户来说是完全透明的。<br>​        每个虚拟路由器都有一个唯一的标识号，称为VRID，一个VRID与一组IP地址构成一个虚拟路由器，在VRRP协议中，所有的报文都是通过IP多播方式发送的，而在一个虚拟路由器中，只有处于Master角色的路由器会一直发送VRRP数据包，处于BACKUP角色的路由器只会接受Master角色发送过来的报文信息，用来监控Master运行状态，一一般不会发生BACKUP抢占的情况，除非它的优先级更高，而当MASTER不可用时，BACKUP也就无法收到Master发过来的信息，于是就认定Master出现故障，接着多台BAKCUP就会进行选举，优先级最高的BACKUP将称为新的MASTER，这种选举角色切换非常之快，因而保证了服务的持续可用性。</p><h3 id="什么是KeepAlived"><a href="#什么是KeepAlived" class="headerlink" title="什么是KeepAlived"></a>什么是KeepAlived</h3><p>​        KeepAlived起初是为LVS设计的，专门用来监控集群系统中各个服务节点的状态，它根据TCP/IP参考模型的第三、第四层、第五层交换机制检测每个服务节点的状态，如果某个服务器节点出现异常，或者工作出现故障，KeepAlived将检测到，并将出现的故障的服务器节点从集群系统中剔除，这些工作全部是自动完成的，不需要人工干涉，需要人工完成的只是修复出现故障的服务节点。后来KeepAlived又加入了VRRP的功能，VRRP（Vritrual Router Redundancy Protocol,虚拟路由冗余协议)出现的目的是解决静态路由出现的单点故障问题，通过VRRP可以实现网络不间断稳定运行，因此KeepAlived一方面具有服务器状态检测和故障隔离功能，另外一方面也有HA cluster功能，下面介绍一下VRRP协议实现的过程。</p><h3 id="KeepAlived的工作原理"><a href="#KeepAlived的工作原理" class="headerlink" title="KeepAlived的工作原理"></a>KeepAlived的工作原理</h3><p>​        上面我们介绍了KeepAlived通过VRRP实现高可用性的工作原理，而KeepAlived作为一个高性能集群软件，它还能实现对集群中服务器运行状态的监控以及故障隔离，下面我们介绍一下KeepAlived对服务器运行状态和故障隔离的工作原理。</p><p>​        KeepAlived工作在TCP/IP 参考模型的 三层、四层、五层，也就是分别为：网络层，</p><p>传输层和应用层，根据TCP、IP参数模型隔层所能实现的功能，KeepAlived运行机制如下：</p><p>​        <strong>在网络层：我们知道运行这4个重要的协议，互联网络IP协议，互联网络可控制报文协议ICMP、地址转换协议ARP、反向地址转换协议RARP，在网络层KeepAlived在网络层采用最常见的工作方式是通过ICMP协议向服务器集群中的每一个节点发送一个ICMP数据包(有点类似与Ping的功能)，如果某个节点没有返回响应数据包，那么认为该节点发生了故障，KeepAlived将报告这个节点失效，并从服务器集群中剔除故障节点。</strong></p><p>​        <strong>在传输层：提供了两个主要的协议：传输控制协议TCP和用户数据协议UDP，传输控制协议TCP可以提供可靠的数据输出服务、IP地址和端口，代表TCP的一个连接端，要获得TCP服务，需要在发送机的一个端口和接收机的一个端口上建立连接，而KeepAlived在传输层里利用了TCP协议的端口连接和扫描技术来判断集群节点的端口是否正常，比如对于常见的WEB服务器80端口。或者SSH服务22端口，KeepAlived一旦在传输层探测到这些端口号没有数据响应和数据返回，就认为这些端口发生异常，然后强制将这些端口所对应的节点从服务器集群中剔除掉。</strong></p><p>​        <strong>在应用层：可以运行FTP，TELNET，SMTP，DNS等各种不同类型的高层协议，KeepAlived的运行方式也更加全面化和复杂化，用户可以通过自定义KeepAlived工作方式，例如：可以通过编写程序或者脚本来运行KeepAlived，而KeepAlived将根据用户的设定参数检测各种程序或者服务是否允许正常，如果KeepAlived的检测结果和用户设定的不一致时，KeepAlived将把对应的服务器从服务器集群中剔除</strong></p><p><a href="https://www.cnblogs.com/losbyday/p/5841830.html">KeepAlived介绍来源</a></p><h2 id="常见的互联网结构"><a href="#常见的互联网结构" class="headerlink" title="常见的互联网结构"></a>常见的互联网结构</h2><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/%E5%85%B8%E5%9E%8B%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%93%E6%9E%84.png" alt="典型互联网结构"></p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/%E5%85%B8%E5%9E%8B%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%93%E6%9E%84.png" alt="典型多模块互联网结构"></p><p>​        上图代理服务器的Nginx可以和代理Web-Service的不为同一台。</p><p>​        从上图可以看出在生产环境上很多时候是以<code>Nginx</code>做反向代理对外提供服务，但是<code>Nginx</code>难免会遇见故障，如果<code>Nginx</code>服务器宕机那么所有对外提供的接口都将导致无法访问。系统还有很多地方都能实现高可用，我今天分享的是实现服务的Nginx服务的高可用。</p><p>​        所以我们实现【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p><h2 id="故障说明"><a href="#故障说明" class="headerlink" title="故障说明"></a>故障说明</h2><p>​        例如上图的典型多模块互联网结构图，如果我们是前后端分离的项目，后台服务有多个模块，那么这时通常的做法是通过一个Nginx服务器反向代理这些模块分别部署的服务器，对外提供一个统一的URL地址供Web-Service端调用，Nginx根据Web-Service调用的请求URL，转发请求给对应的服务器上的服务。如果这些转发URL请求的Nginx服务器挂了，那么就无法再进行请求转发，Web-Service端也就会请求报错。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>两台虚拟机IP为：192.168.102.132/133地址以你的实际地址为准</p><p>更换yum源：</p><p>下载wget(下载新的CentOS-Base.repo 时用到也可以不下载；使用curl代替)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install wget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>备份源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载新的CentOS-Base.repo 到 /etc/yum.repos.d/ (CentOS7)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清除缓存</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum clean all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成缓存</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装JDK8"><a href="#安装JDK8" class="headerlink" title="安装JDK8"></a>安装JDK8</h3><p>去<a href="https://www.oracle.com/index.html">Oracle官网</a>下载JDK8（PS：注意选择Linux对应的版本下载）</p><p>创建目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/java/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后，使用xftp上传到虚拟机/usr/local/java/目录下，进入/usr/local/java/执行解压命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf jdk-8u301-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后/usr/local/java/目录下的文件</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924113356605.png" alt="image-20210924113356605"></p><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在末尾添加</p><pre class="line-numbers language-none"><code class="language-none">export JAVA_HOME=/usr/local/java/jdk1.8.0_301    #你对应的路径，如我上图解压完成的就是/usr/local/java/jdk1.8.0_301export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924113702447.png" alt="image-20210924113702447"></p><p>保存退出</p><p>使环境变量生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建软链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ln -s /usr/local/java/jdk1.8.0_301/bin/java /usr/bin/java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现下图说明安装成功</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924113940922.png" alt="image-20210924113940922"></p><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p>在<a href="https://tomcat.apache.org/">Tomcat官网</a>下载Tomcat9安装包</p><p>创建目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/tomcat/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后，使用xftp上传到虚拟机/usr/local/tomcat/目录下，进入/usr/local/tomcat/执行解压命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf apache-tomcat-9.0.53.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后/usr/local/tomcat/目录下的文件</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924134351811.png" alt="image-20210924134351811"></p><p>进入tomcat的bin目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd apache-tomcat-9.0.53/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建setenv.sh</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi setenv.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">CATALINA_HOME=/usr/local/tomcat/apache-tomcat-9.0.53   #你的Tomcat安装目录CATALINA_BASE=/usr/local/tomcat/apache-tomcat-9.0.53   #你的Tomcat安装目录JAVA_HOME/usr/local/java/jdk1.8.0_301                  #你的Java安装目录JRE_HOME=/usr/local/java/jdk1.8.0_301/jre/             #你的Java安装目录下的jre目录CATALINA_PID=/usr/local/tomcat/apache-tomcat-9.0.53/tomcat.pid    #你的Tomcat安装目录JAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>给setenv.sh权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x setenv.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换至/usr/lib/systemd/system</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/lib/systemd/system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建tomcat.service</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi tomcat.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">[Unit]Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/tomcat/apache-tomcat-9.0.53/tomcat.pid   #和前面配置的CATALINA_PID一致ExecStart=/usr/local/tomcat/apache-tomcat-9.0.53/bin/startup.sh #/usr/local/tomcat/apache-tomcat-9.0.53你的Tomcat安装目录ExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>配置开机启动 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动Tomcat</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止Tomcat</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启Tomcat</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在游览器输入你的IP地址:8080看到一只小喵咪表示Tomcat安装成功并成功启动；如果不能访问检查是不是没有开放端口，因为是虚拟机所以我直接关闭防火墙也就行了，<strong>如果是生产环境不建议关闭防火墙，应该是开放对应的端口，如果是云服务器，例如阿里云ECS服务器，在云服务器的安全组里面配置开放对应的端口就可以了</strong></p><p>查看防火墙状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --state<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止防火墙</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>禁止防火墙开机启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl disable firewalld.service <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CentOS7开放端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone=public --add-port=8080/tcp --permanent  # 开放8080端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CentOS7关闭端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone=public --remove-port=8080/tcp --permanent  #关闭82080端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启防火墙</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开放端口后再次访问，就可以看到小猫咪了如下图</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924140343019.png" alt="image-20210924140343019"></p><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>安装所需插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install gcc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y pcre pcre-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y zlib zlib-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y openssl openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些插件都是安装Nginx所必须的，具体每个插件的作用就不做详细说明，有兴趣的自己百度就可以了。</p><p>下载Nginx，在<a href="http://nginx.org/en/download.html">Nginx官网下载地址</a>下载你需要的版本就可以了，这里我下载的是最新的nginx-1.20.1最新的稳定版本</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924142013728.png" alt="image-20210924142013728"></p><p>创建目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir /usr/local/nginx/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后，使用xftp上传到虚拟机/usr/local/nginx/目录下，进入/usr/local/nginx/执行解压命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf  nginx-1.20.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后/usr/local/nginx/目录下的文件,，解压完成应该只有下图红框框出来的两个文件，其余的是在nginx安装完成后有的</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924142250384.png" alt="image-20210924142250384"></p><p>进入刚刚解压出来的nginx-1.20.1文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd nginx-1.20.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下三个命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure    #配置Nginx编译选项,默认即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make   #编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make install   #编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>三个命令执行完成后切换到/usr/local/nginx安装目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/nginx/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入conf配置目录，配置nginx.conf文件（后面做高可用时需修改，现在暂时不需要）</p><p>切换目录到/usr/local/nginx/sbin下面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看nginx服务是否启动成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps -ef | grep nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924143113017.png" alt="image-20210924143113017"></p><p>如上图所示表示启动成功，在游览器里面输入你的IP地址，应该能看到下面的这张图</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924143307085.png" alt="image-20210924143307085"></p><p>如果不行，参考上面Tomcat安装，开放端口80</p><p>配置nginx开机启动</p><p>进入/lib/systemd/system/目录，创建nginx.service文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /lib/systemd/system/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">[Unit]Description=nginx After=network.target    [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx reloadExecStop=/usr/local/nginx/sbin/nginx quitPrivateTmp=true    [Install] WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>执行systemctl enable nginx.service使nginx开机启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结束nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h3><p><code>yum</code>方式直接安装即可，该方式会自动安装依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install keepalived<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>yum</code>方式安装的会生产配置文件在<code>/etc/keepalived</code>下：</p><p>切换到/etc/keepalived目录编辑keepalived.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /etc/keepalived<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi keepalived.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑keepalived.conf为以下内容(<strong>PS：当前操作的虚拟机为主机，后面还有一台虚拟机作为备机，两个虚拟机环境一致，唯一配置不同的就是keepalived.conf文件主机的state为MASTER；备机的为BACKUP</strong>)</p><pre class="line-numbers language-none"><code class="language-none">#检测脚本vrrp_script chk_http_port {    script "/usr/local/src/check_nginx_pid.sh" #心跳执行的脚本，检测nginx是否启动    interval 2                          #（检测脚本执行的间隔，单位是秒）    weight 2                            #权重}#vrrp 实例定义部分vrrp_instance VI_1 {    state MASTER            # 指定keepalived的角色，MASTER为主，BACKUP为备    interface ens33         # 当前进行vrrp通讯的网络接口卡(当前centos的网卡) 用ifconfig查看你具体的网卡    virtual_router_id 66    # 虚拟路由编号，主从要一直    priority 100            # 优先级，数值越大，获取处理请求的优先级越高    advert_int 1            # 检查间隔，默认为1s(vrrp组播周期秒数)    #授权访问    authentication {        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信        auth_pass 1111    }    track_script {        chk_http_port            #（调用检测脚本）    }    virtual_ipaddress {        192.168.102.199            # 定义虚拟ip(VIP)，可多设，每行一个    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>virtual_ipaddress</code> 里面可以配置vip,在线上通过vip来访问服务。</p><p><code>interface</code>需要根据服务器网卡进行设置通常查看方式 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip addr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>authentication</code>配置授权访问后备机也需要相同配置</p><p>进入/usr/local/src目录创建心跳执行的脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/src/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim check_nginx_pid.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入</p><pre class="line-numbers language-none"><code class="language-none">#!/bin/bash#检测nginx是否启动了A=`ps -C nginx --no-header |wc -l`        if [ $A -eq 0 ];then    #如果nginx没有启动就启动nginx                              systemctl start nginx                #重启nginx      if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then    #nginx重启失败，则停掉keepalived服务，进行VIP转移              killall keepalived                          fifi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出</p><p>脚本授权</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 775 check_nginx_pid.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此我们需要的环境已经搭建完成，现在我们编写一个简单的服务，然后发布来测试一下，我用的是IntelliJ IDEA创建的一个Spring Boot项目</p><h2 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="创建测试项目"></a>创建测试项目</h2><p>创建过程如下</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924145830502.png" alt="image-20210924145830502"></p><p>填写你的项目信息</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924145847814.png" alt="image-20210924145847814"></p><p>如下为我的配置信息，勾选packaging为War会自动帮我们配置打包移除内置Spring Boot内置的Tomcat</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924150033206.png" alt="image-20210924150033206"></p><p>勾选你需要的依赖，因为是测试项目不需要任何依赖，所以直接点击Finish，等待项目创建完成</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924145928902.png" alt="image-20210924145928902"></p><p>创建完成后我们在目录下建一个controller文件夹，在下面建一个TestHighAvailabilityController.java文件，结构如下图</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924150339524.png" alt="image-20210924150339524"></p><p>这里有点注意事项；我们新创建的项目的配置文件为application.properties文件，我们修改其为application.yml然后在里面写入</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 9000     #配置项目启动端口,默认为8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们在TestHighAvailabilityController.java写入一下代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.tan.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @description: 高可用测试接口 * @author: tan * @email: tan2511217211@163.com * @date: 2021/9/23 23:18 **/@RestController@RequestMapping("/api")public class TestHighAvailabilityController {    @GetMapping("/test")    public String test(){        return "Message from IP: 192.168.102.132/3";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我为了后面能直观的看到高可用实现了请求切换，所以我的返回语句分别是Message from IP: 192.168.102.133和Message from IP: 192.168.102.132</p><p>打两次包，把</p><p>返回信息为<strong>Message from IP: 192.168.102.132</strong>打的包放到<strong>192.168.102.132</strong>这个IP的服务器上；</p><p>返回信息为<strong>Message from IP: 192.168.102.133</strong>打的包放到<strong>192.168.102.133</strong>这个IP的服务器上；</p><p>编写完执行打包命令（可使用命令，亦可以直接在IDEA里面使用插件的打包命令，如果使用IDEA的maven插件按下图依次执行）</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924151247424.png" alt="image-20210924151247424"></p><p>然后把打包生成的war包分别上传至两台虚拟机</p><p>然后配置Nginx反向代理</p><p>在nginx.conf文件里面新增一个location配置，写入以下内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location ^~/highAvailability/ {                                    #highAvailability为你的请求前缀proxy_pass   http://192.168.102.132:9000/highAvailability/;    #你的服务地址}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如下图所示</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924151727948.png" alt="image-20210924151727948"></p><p>192.168.102.133的服务器只需把IP地址变更就行，和上面的配置一样</p><p>配置Tomcat</p><p>因为使用的是外部部署的方式，所以我们在application.yml里面配置的</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 9000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>没有效果，我们需要在安装的Tomcat里面修改Tomcat配置才有效</p><p>进入Tomcat安装目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd /usr/local/tomcat/apache-tomcat-9.0.53<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个webapps1文件夹，里面存放我们刚刚上传的war包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir webapps1/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入conf目录修改server.xml文件，我们需要在server.xml里面新增我们刚刚创建的webapps1配置，新增内容如下</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Service</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Catalina<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>9000<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span>               <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span>               <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Engine</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Catalina<span class="token punctuation">"</span></span> <span class="token attr-name">defaultHost</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Realm</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.catalina.realm.LockOutRealm<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Realm</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.catalina.realm.UserDatabaseRealm<span class="token punctuation">"</span></span>                   <span class="token attr-name">resourceName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UserDatabase<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Realm</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Host</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span>  <span class="token attr-name">appBase</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>webapps1<span class="token punctuation">"</span></span>              <span class="token attr-name">unpackWARs</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">autoDeploy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.catalina.valves.AccessLogValve<span class="token punctuation">"</span></span> <span class="token attr-name">directory</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logs<span class="token punctuation">"</span></span>                   <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localhost_access_log<span class="token punctuation">"</span></span> <span class="token attr-name">suffix</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.txt<span class="token punctuation">"</span></span>                   <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>%h %l %u %t <span class="token entity named-entity" title="&quot;">&amp;quot;</span>%r<span class="token entity named-entity" title="&quot;">&amp;quot;</span> %s %b<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Host</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Engine</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Service</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体如下图所示</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152425389.png" alt="image-20210924152425389"></p><p>与默认配置唯一的区别就是appBase，两台虚拟机配置一样</p><p>配置完成后重启Tomcat，Nginx,KeepAlived然后再游览器访问我们在KeepAlived配置的VIP(<strong>我设置的为192.168.102.199</strong>)地址</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152700511.png" alt="image-20210924152700511"></p><p>可以看到这时返回的是IP为192.168.102.132虚拟机服务的信息，这时我们停掉192.168.102.132虚拟机的nginx服务</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152831109.png" alt="image-20210924152831109"></p><p>再次访问发现返回信息已经变成192.168.102.133虚拟机服务返回的信息了，如下图所示</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210924152926940.png" alt="image-20210924152926940"></p><p>至此，我们就已经实现了服务的高可用。</p><p>文章不足之处，可以在下面评论交流</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> KeepAlived </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高可用 </tag>
            
            <tag> nginx </tag>
            
            <tag> keepalived </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫爬取豆瓣电影白蛇评论</title>
      <link href="/posts/ac3c.html"/>
      <url>/posts/ac3c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Python爬虫爬取豆瓣电影评论内容，评论时间和评论人"><a href="#Python爬虫爬取豆瓣电影评论内容，评论时间和评论人" class="headerlink" title="Python爬虫爬取豆瓣电影评论内容，评论时间和评论人"></a>Python爬虫爬取豆瓣电影评论内容，评论时间和评论人</h2><p>我们可以看到影评比较长，需要展开才能完整显示。但是在网页源码中是没有显示完整影评的。所以我们考虑到这部分应该是异步加载的方式显示。所以打开网页的开发者选项，可以看到点击展开之后，多了一条full的网页。这个网页就包含了完整评论。<br>我们观察到全部评论所在的网址为<a href="https://movie.douban.com/j/review/9593388/full">https://movie.douban.com/j/review/9593388/full</a></p><p>获取索引页<a href="https://movie.douban.com/review/best/?start=0%EF%BC%8C%E7%B4%A2%E5%BC%95%E9%A1%B5%E5%8F%AA%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98start=0,20,40%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE%E4%B8%8B%E4%B8%80%E9%A1%B5">https://movie.douban.com/review/best/?start=0，索引页只需要改变start=0,20,40即可访问下一页</a><br>解析索引页，把索引页中的10个评论的ID获取到<br>通过获取到的ID构建完整评论网址<a href="https://movie.douban.com/j/review/'">https://movie.douban.com/j/review/'</a> + str(id) + ‘/full<br>解析评论页，获取评论者姓名和评论内容，写入txt文件<br>附上源码：</p><pre class="line-numbers language-none"><code class="language-none">import urllib.requestimport recomment = '白蛇.txt'T='&lt;span content=".*?" class=".*?"&gt;.*?&lt;/span&gt;'for i in range(10):    print("获取第"+str(i+1)+"页")    url = "https://movie.douban.com/subject/30331149/reviews?start="+str(i*20)  # 确定要爬取的入口链接     # 模拟成浏览器并爬取对应的网页 谷歌浏览器    headers = {'User-Agent',               'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36'}    opener = urllib.request.build_opener()    opener.addheaders = [headers]    data = opener.open(url).read().decode('utf8')    time_pattern = re.compile('&lt;span content=".*?" class=".*?"&gt;(.*?)&lt;/span&gt;', re.S)    time = re.findall(time_pattern, data)    id_pattern= re.compile('&lt;h2&gt;&lt;a href="https://movie.douban.com/review/(.*?)/', re.S)    id= re.findall(id_pattern, data)    for j in range(len(id)):        html = 'https://movie.douban.com/j/review/' + str(id[j]) + '/full'        data = opener.open(html).read().decode('utf8')        html = data        content_pattern = re.compile('data-original(.*?)main-author', re.S)        content = re.findall(content_pattern, html)        text_pattern = re.compile('[\u4e00-\u9fa5|，、“”‘’：！~@#￥【】*（）——+。；？]+', re.S)        text = re.findall(text_pattern, content[0])        text = ''.join(text)        name_pattern = re.compile('data-author=.*?"(.*?)"', re.S)        name = re.findall(name_pattern, html)        with open(comment, 'a', encoding='utf-8-sig') as f:            f.write(name[0].strip('\\') + '\n')            f.write(time[j]+'\n')            f.write(str(text) + '\n')            f.write('\n')            f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 豆瓣 </tag>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫爬取淘宝商品信息</title>
      <link href="/posts/4818.html"/>
      <url>/posts/4818.html</url>
      
        <content type="html"><![CDATA[<h2 id="爬虫爬取淘宝商品信息"><a href="#爬虫爬取淘宝商品信息" class="headerlink" title="爬虫爬取淘宝商品信息"></a>爬虫爬取淘宝商品信息</h2><p>前面已经写过一篇获取淘宝信息的文章，但是那篇文章并没有获取商品详情页下面的信息，也没有数据保存功能，这篇文章就是在上篇文章上增加了商品详情页信息的获取和数据保存为xls文件，原理和上一篇文章一样，故不做过多介绍，想看看原理的请看上一篇博客，博客传送门<a href="https://blog.csdn.net/qq_43764365/article/details/103539728">爬虫爬取京东和淘宝商品信息</a>。不明白的老规矩，评论区留言讨论或者加QQ2511217211（加Q请备注讨论，否则不予通过）。<br>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># coding=UTF-8from selenium import webdriverfrom time import sleepimport randomimport reimport osimport xlrdimport xlwtfrom xlutils.copy import copy# 获取页码def search_products():    driver.find_element_by_xpath('//*[@id="q"]').send_keys(keyword)    driver.find_element_by_xpath('//*[@id="J_TSearchForm"]/div[1]/button').click()    sleep(60)    token = driver.find_element_by_xpath('//*[@id="mainsrp-pager"]/div/div/div/div[1]').text    # 0代表所有匹配到的数字    token = int(re.compile('(\d+)').search(token).group(1))    return token# 下拉下滑条，加载数据def drop_down():    for x in range(1, 11, 2):        sleep(1)        j = x / 10        js = 'document.documentElement.scrollTop = document.documentElement.scrollHeight * %f' % j        driver.execute_script(js)# 获取商品信息def get_product(page):    oldHandle = driver.window_handles    lis = driver.find_elements_by_xpath('//div[@class="items"]/div[@class="item J_MouserOnverReq  "]')    for i in range(len(lis)):        print("获取第{}页第{}条中...".format(page, i + 1))        li = driver.find_elements_by_xpath('//div[@class="items"]/div[@class="item J_MouserOnverReq  "]')[i]        sales = ''        # 商品信息        info = li.find_element_by_xpath('.//div[@class="row row-2 title"]').text        # 价格        price = li.find_element_by_xpath('.//a[@class="J_ClickStat"]').get_attribute('trace-price')        # 付款人数        deal = li.find_element_by_xpath('.//div[@class="deal-cnt"]').text        # 只留数字,便于数据分析        deal = int(re.compile('(\d+)').search(deal).group(1))        # 封面图片地址        image = li.find_element_by_xpath('.//div[@class="pic"]/a/img').get_attribute('src')        # 商家名称        name = li.find_element_by_xpath('.//div[@class="shop"]/a/span[2]').text        # 商家地址        site = li.find_element_by_xpath('.//div[@class="location"]').text        # 详情页地址        href = li.find_element_by_xpath('.//a[@class="J_ClickStat"]').get_attribute('href')        li.click()        handles = driver.window_handles        handle = list(set(oldHandle) ^ set(handles))        oldHandle = list(set(oldHandle) &amp; set(handles))        driver.switch_to.window(handle[0])        storeType = href[8:].split('/')[0]        if storeType == 'detail.tmall.com':            # 店铺在天猫上            sales = driver.find_element_by_xpath(                '//*[@id="J_DetailMeta"]/div[1]/div[1]/div/ul/li[1]/div/span[2]').text        elif storeType == 'item.taobao.com':            # 店铺在淘宝上            sales = driver.find_element_by_xpath('//*[@id="J_SellCounter"]').text        else:            # 既不是天猫也不是淘宝直接跳过            pass        # 月销量        sales = int(re.compile('(\d+)').search(sales).group(1))        # 月销额        monthlySales = sales * float(price)        flag = MakeRandomNumbers(1, 100)        if flag % 3 == 0 or flag % 8 == 0:            drop_down()        # 随机睡眠10~20秒,接口有防盗刷        markAmount = MakeRandomNumbers(i, len(lis)) % 10        sleep(MakeRandomNumbers(5 * markAmount, 20 * markAmount))        driver.close()        driver.implicitly_wait(10)        driver.switch_to.window(oldHandle[0])        value = [[info, price, deal, name, site, sales, monthlySales], ]        write_excel_xls_append(book_name_xls, value)        # print(info, price, deal, name, site, sales, monthlySales, image, sep='|')# 生成随机数def MakeRandomNumbers(a, b):    return random.randint(a, b)# 随机休眠def dormancy(a, b):    sleep(random.randint(a, b))# 翻页def next_page():    token = search_products()    num = 0    while num != token:        dormancy(60, 120)  # 随机休眠一到两分钟        driver.get('https://s.taobao.com/search?q={}&amp;s={}'.format(keyword, 44 * num))        driver.implicitly_wait(10)        num += 1        drop_down()        get_product(num)# 创建Excel数据表并写入表头数据def write_excel_xls_head(path, sheet_name, value):    index = len(value)  # 获取需要写入数据的行数    workbook = xlwt.Workbook()  # 新建一个工作簿    sheet = workbook.add_sheet(sheet_name)  # 在工作簿中新建一个表格    for i in range(0, index):        for j in range(0, len(value[i])):            sheet.write(i, j, value[i][j])  # 像表格中写入数据（对应的行和列）    workbook.save(path)  # 保存工作簿    print("表头写入成功！")# 写入表格数据def write_excel_xls_append(path, value):    index = len(value)  # 获取需要写入数据的行数    workbook = xlrd.open_workbook(path)  # 打开工作簿    sheets = workbook.sheet_names()  # 获取工作簿中的所有表格    worksheet = workbook.sheet_by_name(sheets[0])  # 获取工作簿中所有表格中的的第一个表格    rows_old = worksheet.nrows  # 获取表格中已存在的数据的行数    new_workbook = copy(workbook)  # 将xlrd对象拷贝转化为xlwt对象    new_worksheet = new_workbook.get_sheet(0)  # 获取转化后工作簿中的第一个表格    for i in range(0, index):        for j in range(0, len(value[i])):            new_worksheet.write(i + rows_old, j, value[i][j])  # 追加写入数据，注意是从i+rows_old行开始写入    new_workbook.save(path)  # 保存工作簿if __name__ == "__main__":    book_name_xls = '淘宝商品数据.xls'    sheet_name_xls = '商品数据表'    value_title = [["商品信息", "价格", "付款人数", "商家名称", "商家地址", "月销量", "月销金额"], ]    write_excel_xls_head(book_name_xls, sheet_name_xls, value_title)    driver_path = os.path.abspath(os.path.join(os.getcwd(), ".")) + "/dr/chromedriver.exe"    keyword = input('输入你想查找的商品名字:')    options = webdriver.ChromeOptions()    # options.add_argument("--no-sandbox")    # options.add_argument('lang=zh_CN.UTF-8')    options.add_argument('--start-maximized')    # options.add_argument("--headless") 无界面模式 options.add_argument('user-agent="Mozilla/5.0 (Windows NT 10.0; Win64;    # x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36"')    # options.add_experimental_option("prefs", {"profile.managed_default_content_settings.images": 2})  # 不加载图片,加快访问速度    options.add_experimental_option('excludeSwitches', ['enable-automation'])  # 此步骤很重要，设置为开发者模式，防止被各大网站识别出来使用了Selenium    driver = webdriver.Chrome(executable_path=driver_path, options=options)    driver.get('https://www.taobao.com/')    next_page()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存的数据文件截图<br><img src="https://img-blog.csdnimg.cn/20210531112941554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzY0MzY1,size_16,color_FFFFFF,t_70" alt="数据"><br>文章只是一种学习方法，效率不是很高，要追求效率老老实实抓包分析，然后伪造请求，改分页参数一次性就可以获取几百条。但是那样的难度上升的层级不止一点半点。有兴趣的可以在评论区讨论。<br><strong>声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> 淘宝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/a2d2.html"/>
      <url>/posts/a2d2.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h1></blockquote><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><p>同一个类的不同对象的Hash Code不同</p></li><li><p>形容词用接口，名词用抽象类</p></li><li><p>设计模式常用的七大原则</p><ol><li><p><strong>单一职责原则：控制类的颗粒度大小、将对象解耦、提高其内聚性</strong></p><p><strong>基本介绍</strong></p><p>对类来说，即一个类应该只负责意向职责。</p><p><strong>注意事项和细节</strong></p><ol><li>降低类的复杂度，一个类只负责一项职责</li><li>提高类的可读性、可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li></ol></li><li><p><strong>接口隔离原则：要为各个类建立它们需要的专用接口</strong></p><p><strong>基本介绍</strong></p><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><p><strong>应传统方法的问题和使用接口隔离原则改进</strong></p><ol><li>类A通过接口interface1依赖类B，类C通过接口interfa1依赖类D，如果接口interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法</li><li>将接口interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</li><li>接口interface1中出现的方法，根据实际情况拆分为三个接口</li><li>代码实现</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829095930685.png" alt="image-20210829095930685"></p></li><li><p><strong>依赖倒转原则：要面向接口编程，不要面向实现编程</strong></p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转（倒置）的中心思想是面向接口编程</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ol><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829102317701.png" alt="image-20210829102317701.png"></p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829102400935.png" alt="image-20210829102400935"></p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210829102515810.png" alt="image-20210829102515810"></p></li><li><p><strong>里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立</strong></p><p><strong>OO中的继承性的思考和说明</strong></p><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时，也带来了弊端。比如原来使用继承会给其他程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。</li><li>问题提出：在编程中，如何正确的使用继承？——————————————————&gt;里氏替换原则</li></ol><p><strong>里氏替换原则基本介绍</strong></p><ol><li>里氏替换原则在1988年，有麻省理工学院的一位姓里的女士提出的。</li><li>如果对每个类型为T1的对象O1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1都代换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句换说，所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</li><li>里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</li></ol></li><li><p><strong>开闭原则(Open Closed Principle):对扩展开放，对修改关闭</strong></p><p><strong>基本介绍</strong></p><ol><li>是编程中最基础、最重要的设计原则</li><li>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</li></ol></li><li><p><strong>迪米特法则：只跟你的直接朋友交谈，不跟“陌生人”说话</strong></p><p><strong>基本介绍</strong></p><ol><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li><li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li></ol><p><strong>迪米特法则注意事项和细节</strong></p><ol><li>迪米特法则的核心是降低类之间的耦合</li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</li></ol></li><li><p><strong>合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong></p><p><strong>基本介绍</strong></p><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210912221606552.png" alt="image-20210912221606552"></p></li></ol></li><li><p><strong>设计原则核心思想</strong></p><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li></ol></li><li><p><strong>UML基本介绍</strong></p><ol><li>UML(Unified modeling language UML) 统一建模语言，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</li><li>UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</li><li>使用UML来建模，常用的工具有Rational Rose , 也可以使用一些插件来建模</li></ol></li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li>单例：单个实例</li><li>应用场景：只需要一个实例存在（如：各种manager，各种factory等）</li><li>保证实例在内存中只有一个实例定义一个static final 实例 INSTANCE；例如（private static final Mgr01 INSTANCE = new Mgr01();）</li><li>注意：单例模式需要防止反序列化（Java的反射可以通过实例.class漏到内存中，然后再new一个实例出来，enum可以防止反序列化，能防止的原因是因为enum没有构造方法，就算拿到class文件也无法构造对象，它的反序列化返回的只是一个（INSTANCE）值）</li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul><li><p>策略模式封装的是做一件事情时不同的执行方式</p><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210717181341796.png" alt="策略模式类图"></p></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul><li>工厂：任何可以产生对象的方法或类，都可以称之为工厂</li><li>单例也是一种工厂</li><li>为什么有了new之后，还要有工厂？<ul><li>灵活控制生产过程</li><li>权限、修饰、日志…</li></ul></li><li>工厂分类：<ol><li>简单工厂</li><li>静态工厂</li><li>工厂方法FactoryMethod<ul><li>产品维度扩展</li></ul></li><li>抽象工厂<ul><li>产品一族扩展</li></ul></li></ol></li></ul><h3 id="门面与调停者"><a href="#门面与调停者" class="headerlink" title="门面与调停者"></a>门面与调停者</h3><ul><li>facade门面：要和系统中的多个类打交道，还必须理解这多个类之前的关系，太麻烦了，可以直接把这些错综复杂关系的类用一个Facade门面封装起来，就是对外的一个门面，调用者只需要和这个门面打交道即可。</li><li>mediator调停者：部门内部打交道。每个类之间都不要互相打交道了，都通过一个调停者来交互。</li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><ul><li>装饰器设计模式</li></ul><img src="C:\Users\tan25\AppData\Roaming\Typora\typora-user-images\image-20210814125156218.png" alt="image-20210814125156218"><p><img src="https://gitee.com/tan2511217211/PicBed/raw/master/images/image-20210814125326725.png" alt="image-20210814125326725"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
